/**
 * Generated by orval v6.10.2 üç∫
 * Do not edit manually.
 * SchoolUtilities API
 * OpenAPI spec version: 1.0
 */
import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from "axios";
import { useQuery, useMutation } from "@tanstack/react-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from "@tanstack/react-query";
import type {
  LogEmail,
  GetLogEmailDTO,
  Course,
  AddCourseDTO,
  DeleteCourseDTO,
  UpdateCourseDTO,
  AddCourseUserDTO,
  RemoveCourseUserDTO,
  Holiday,
  AddHolidayDTO,
  UpdateHolidayDTO,
  AddExamDTO,
  UpdateExamDTO,
} from "../../backend/src/model";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Get a logo varient by it's name
 */
export const assetsControllerGetLogo = (
  logoname: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/assets/logos/${logoname}`, options);
};

export const getAssetsControllerGetLogoQueryKey = (logoname: string) => [
  `/api/assets/logos/${logoname}`,
];

export type AssetsControllerGetLogoQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetLogo>>
>;
export type AssetsControllerGetLogoQueryError = AxiosError<unknown>;

export const useAssetsControllerGetLogo = <
  TData = Awaited<ReturnType<typeof assetsControllerGetLogo>>,
  TError = AxiosError<unknown>
>(
  logoname: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof assetsControllerGetLogo>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetLogoQueryKey(logoname);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetLogo>>
  > = ({ signal }) =>
    assetsControllerGetLogo(logoname, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof assetsControllerGetLogo>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!logoname,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get an image by it's name
 */
export const assetsControllerGetImage = (
  filename: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/assets/images/${filename}`, options);
};

export const getAssetsControllerGetImageQueryKey = (filename: string) => [
  `/api/assets/images/${filename}`,
];

export type AssetsControllerGetImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetImage>>
>;
export type AssetsControllerGetImageQueryError = AxiosError<unknown>;

export const useAssetsControllerGetImage = <
  TData = Awaited<ReturnType<typeof assetsControllerGetImage>>,
  TError = AxiosError<unknown>
>(
  filename: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof assetsControllerGetImage>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerGetImageQueryKey(filename);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetImage>>
  > = ({ signal }) =>
    assetsControllerGetImage(filename, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof assetsControllerGetImage>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!filename,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get a file submission by it's UUID
 */
export const assetsControllerGetSubmission = (
  fileUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/assets/submissions/${fileUUID}`, options);
};

export const getAssetsControllerGetSubmissionQueryKey = (fileUUID: string) => [
  `/api/assets/submissions/${fileUUID}`,
];

export type AssetsControllerGetSubmissionQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerGetSubmission>>
>;
export type AssetsControllerGetSubmissionQueryError = AxiosError<unknown>;

export const useAssetsControllerGetSubmission = <
  TData = Awaited<ReturnType<typeof assetsControllerGetSubmission>>,
  TError = AxiosError<unknown>
>(
  fileUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof assetsControllerGetSubmission>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAssetsControllerGetSubmissionQueryKey(fileUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerGetSubmission>>
  > = ({ signal }) =>
    assetsControllerGetSubmission(fileUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof assetsControllerGetSubmission>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!fileUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get a list of all logos
 */
export const assetsControllerListLogos = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/assets/list/logo`, options);
};

export const getAssetsControllerListLogosQueryKey = () => [
  `/api/assets/list/logo`,
];

export type AssetsControllerListLogosQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerListLogos>>
>;
export type AssetsControllerListLogosQueryError = AxiosError<unknown>;

export const useAssetsControllerListLogos = <
  TData = Awaited<ReturnType<typeof assetsControllerListLogos>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerListLogos>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerListLogosQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerListLogos>>
  > = ({ signal }) => assetsControllerListLogos({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof assetsControllerListLogos>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const assetsControllerListImages = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/assets/list/images`, options);
};

export const getAssetsControllerListImagesQueryKey = () => [
  `/api/assets/list/images`,
];

export type AssetsControllerListImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof assetsControllerListImages>>
>;
export type AssetsControllerListImagesQueryError = AxiosError<unknown>;

export const useAssetsControllerListImages = <
  TData = Awaited<ReturnType<typeof assetsControllerListImages>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof assetsControllerListImages>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAssetsControllerListImagesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof assetsControllerListImages>>
  > = ({ signal }) => assetsControllerListImages({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof assetsControllerListImages>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const authControllerRegisterUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/register`, undefined, options);
};

export type AuthControllerRegisterUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRegisterUser>>
>;

export type AuthControllerRegisterUserMutationError = AxiosError<unknown>;

export const useAuthControllerRegisterUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRegisterUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRegisterUser>>,
    TVariables
  > = () => {
    return authControllerRegisterUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerRegisterUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerLoginUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/login`, undefined, options);
};

export type AuthControllerLoginUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLoginUser>>
>;

export type AuthControllerLoginUserMutationError = AxiosError<unknown>;

export const useAuthControllerLoginUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLoginUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLoginUser>>,
    TVariables
  > = () => {
    return authControllerLoginUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerLoginUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerLinkUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/link`, undefined, options);
};

export type AuthControllerLinkUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLinkUser>>
>;

export type AuthControllerLinkUserMutationError = AxiosError<unknown>;

export const useAuthControllerLinkUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLinkUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLinkUser>>,
    TVariables
  > = () => {
    return authControllerLinkUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerLinkUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerUnlinkUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/unlink`, undefined, options);
};

export type AuthControllerUnlinkUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerUnlinkUser>>
>;

export type AuthControllerUnlinkUserMutationError = AxiosError<unknown>;

export const useAuthControllerUnlinkUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerUnlinkUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerUnlinkUser>>,
    TVariables
  > = () => {
    return authControllerUnlinkUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerUnlinkUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerLoginMobileUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/mobile/login`, undefined, options);
};

export type AuthControllerLoginMobileUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLoginMobileUser>>
>;

export type AuthControllerLoginMobileUserMutationError = AxiosError<unknown>;

export const useAuthControllerLoginMobileUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLoginMobileUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLoginMobileUser>>,
    TVariables
  > = () => {
    return authControllerLoginMobileUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerLoginMobileUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerGetProfile = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/auth/profile`, options);
};

export const getAuthControllerGetProfileQueryKey = () => [`/api/auth/profile`];

export type AuthControllerGetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetProfile>>
>;
export type AuthControllerGetProfileQueryError = AxiosError<unknown>;

export const useAuthControllerGetProfile = <
  TData = Awaited<ReturnType<typeof authControllerGetProfile>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetProfile>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthControllerGetProfileQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authControllerGetProfile>>
  > = ({ signal }) => authControllerGetProfile({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof authControllerGetProfile>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const authControllerRefreshToken = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/auth/refresh`, undefined, options);
};

export type AuthControllerRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRefreshToken>>
>;

export type AuthControllerRefreshTokenMutationError = AxiosError<unknown>;

export const useAuthControllerRefreshToken = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    TVariables
  > = () => {
    return authControllerRefreshToken(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof authControllerRefreshToken>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const authControllerGetRoles = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/auth/roles`, options);
};

export const getAuthControllerGetRolesQueryKey = () => [`/api/auth/roles`];

export type AuthControllerGetRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetRoles>>
>;
export type AuthControllerGetRolesQueryError = AxiosError<unknown>;

export const useAuthControllerGetRoles = <
  TData = Awaited<ReturnType<typeof authControllerGetRoles>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof authControllerGetRoles>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthControllerGetRolesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authControllerGetRoles>>
  > = ({ signal }) => authControllerGetRoles({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof authControllerGetRoles>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get all mails sent to a user
 */
export const mailControllerGetMailsSentToUser = (
  getLogEmailDTO: GetLogEmailDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<LogEmail[]>> => {
  return axios.get(`/api/mail/getUserMails`, options);
};

export const getMailControllerGetMailsSentToUserQueryKey = (
  getLogEmailDTO: GetLogEmailDTO
) => [`/api/mail/getUserMails`, getLogEmailDTO];

export type MailControllerGetMailsSentToUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof mailControllerGetMailsSentToUser>>
>;
export type MailControllerGetMailsSentToUserQueryError = AxiosError<unknown>;

export const useMailControllerGetMailsSentToUser = <
  TData = Awaited<ReturnType<typeof mailControllerGetMailsSentToUser>>,
  TError = AxiosError<unknown>
>(
  getLogEmailDTO: GetLogEmailDTO,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof mailControllerGetMailsSentToUser>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMailControllerGetMailsSentToUserQueryKey(getLogEmailDTO);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof mailControllerGetMailsSentToUser>>
  > = ({ signal }) =>
    mailControllerGetMailsSentToUser(getLogEmailDTO, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof mailControllerGetMailsSentToUser>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Add a course to a school
 */
export const courseControllerAddCourse = (
  addCourseDTO: AddCourseDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Course>> => {
  return axios.post(`/api/course`, addCourseDTO, options);
};

export type CourseControllerAddCourseMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerAddCourse>>
>;
export type CourseControllerAddCourseMutationBody = AddCourseDTO;
export type CourseControllerAddCourseMutationError = AxiosError<unknown>;

export const useCourseControllerAddCourse = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerAddCourse>>,
    TError,
    { data: AddCourseDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerAddCourse>>,
    { data: AddCourseDTO }
  > = (props) => {
    const { data } = props ?? {};

    return courseControllerAddCourse(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerAddCourse>>,
    TError,
    { data: AddCourseDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerRemoveCourse = (
  deleteCourseDTO: DeleteCourseDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/course`, { data: deleteCourseDTO, ...options });
};

export type CourseControllerRemoveCourseMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerRemoveCourse>>
>;
export type CourseControllerRemoveCourseMutationBody = DeleteCourseDTO;
export type CourseControllerRemoveCourseMutationError = AxiosError<unknown>;

export const useCourseControllerRemoveCourse = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerRemoveCourse>>,
    TError,
    { data: DeleteCourseDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerRemoveCourse>>,
    { data: DeleteCourseDTO }
  > = (props) => {
    const { data } = props ?? {};

    return courseControllerRemoveCourse(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerRemoveCourse>>,
    TError,
    { data: DeleteCourseDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerUpdateCourse = (
  updateCourseDTO: UpdateCourseDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/course`, updateCourseDTO, options);
};

export type CourseControllerUpdateCourseMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerUpdateCourse>>
>;
export type CourseControllerUpdateCourseMutationBody = UpdateCourseDTO;
export type CourseControllerUpdateCourseMutationError = AxiosError<unknown>;

export const useCourseControllerUpdateCourse = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerUpdateCourse>>,
    TError,
    { data: UpdateCourseDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerUpdateCourse>>,
    { data: UpdateCourseDTO }
  > = (props) => {
    const { data } = props ?? {};

    return courseControllerUpdateCourse(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerUpdateCourse>>,
    TError,
    { data: UpdateCourseDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerAddUser = (
  addCourseUserDTO: AddCourseUserDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/course/user`, addCourseUserDTO, options);
};

export type CourseControllerAddUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerAddUser>>
>;
export type CourseControllerAddUserMutationBody = AddCourseUserDTO;
export type CourseControllerAddUserMutationError = AxiosError<unknown>;

export const useCourseControllerAddUser = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerAddUser>>,
    TError,
    { data: AddCourseUserDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerAddUser>>,
    { data: AddCourseUserDTO }
  > = (props) => {
    const { data } = props ?? {};

    return courseControllerAddUser(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerAddUser>>,
    TError,
    { data: AddCourseUserDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerRemoveUser = (
  removeCourseUserDTO: RemoveCourseUserDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/course/user`, {
    data: removeCourseUserDTO,
    ...options,
  });
};

export type CourseControllerRemoveUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerRemoveUser>>
>;
export type CourseControllerRemoveUserMutationBody = RemoveCourseUserDTO;
export type CourseControllerRemoveUserMutationError = AxiosError<unknown>;

export const useCourseControllerRemoveUser = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerRemoveUser>>,
    TError,
    { data: RemoveCourseUserDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerRemoveUser>>,
    { data: RemoveCourseUserDTO }
  > = (props) => {
    const { data } = props ?? {};

    return courseControllerRemoveUser(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerRemoveUser>>,
    TError,
    { data: RemoveCourseUserDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerGetCourses = (
  schoolUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/course/courses/${schoolUUID}`, options);
};

export const getCourseControllerGetCoursesQueryKey = (schoolUUID: string) => [
  `/api/course/courses/${schoolUUID}`,
];

export type CourseControllerGetCoursesQueryResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerGetCourses>>
>;
export type CourseControllerGetCoursesQueryError = AxiosError<unknown>;

export const useCourseControllerGetCourses = <
  TData = Awaited<ReturnType<typeof courseControllerGetCourses>>,
  TError = AxiosError<unknown>
>(
  schoolUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof courseControllerGetCourses>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCourseControllerGetCoursesQueryKey(schoolUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof courseControllerGetCourses>>
  > = ({ signal }) =>
    courseControllerGetCourses(schoolUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof courseControllerGetCourses>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!schoolUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const courseControllerGetSubmissions = (
  elementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/course/submissions/${elementUUID}`, options);
};

export const getCourseControllerGetSubmissionsQueryKey = (
  elementUUID: string
) => [`/api/course/submissions/${elementUUID}`];

export type CourseControllerGetSubmissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerGetSubmissions>>
>;
export type CourseControllerGetSubmissionsQueryError = AxiosError<unknown>;

export const useCourseControllerGetSubmissions = <
  TData = Awaited<ReturnType<typeof courseControllerGetSubmissions>>,
  TError = AxiosError<unknown>
>(
  elementUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof courseControllerGetSubmissions>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCourseControllerGetSubmissionsQueryKey(elementUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof courseControllerGetSubmissions>>
  > = ({ signal }) =>
    courseControllerGetSubmissions(elementUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof courseControllerGetSubmissions>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!elementUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const courseControllerGetCourseInfo = (
  courseUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/course/info/${courseUUID}`, options);
};

export const getCourseControllerGetCourseInfoQueryKey = (
  courseUUID: string
) => [`/api/course/info/${courseUUID}`];

export type CourseControllerGetCourseInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerGetCourseInfo>>
>;
export type CourseControllerGetCourseInfoQueryError = AxiosError<unknown>;

export const useCourseControllerGetCourseInfo = <
  TData = Awaited<ReturnType<typeof courseControllerGetCourseInfo>>,
  TError = AxiosError<unknown>
>(
  courseUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof courseControllerGetCourseInfo>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCourseControllerGetCourseInfoQueryKey(courseUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof courseControllerGetCourseInfo>>
  > = ({ signal }) =>
    courseControllerGetCourseInfo(courseUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof courseControllerGetCourseInfo>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!courseUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const courseControllerCourseElements = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/course/courseElements`, undefined, options);
};

export type CourseControllerCourseElementsMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerCourseElements>>
>;

export type CourseControllerCourseElementsMutationError = AxiosError<unknown>;

export const useCourseControllerCourseElements = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerCourseElements>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerCourseElements>>,
    TVariables
  > = () => {
    return courseControllerCourseElements(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerCourseElements>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerGetCourseElements = (
  courseUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/course/courseElements/${courseUUID}`, options);
};

export const getCourseControllerGetCourseElementsQueryKey = (
  courseUUID: string
) => [`/api/course/courseElements/${courseUUID}`];

export type CourseControllerGetCourseElementsQueryResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerGetCourseElements>>
>;
export type CourseControllerGetCourseElementsQueryError = AxiosError<unknown>;

export const useCourseControllerGetCourseElements = <
  TData = Awaited<ReturnType<typeof courseControllerGetCourseElements>>,
  TError = AxiosError<unknown>
>(
  courseUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof courseControllerGetCourseElements>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCourseControllerGetCourseElementsQueryKey(courseUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof courseControllerGetCourseElements>>
  > = ({ signal }) =>
    courseControllerGetCourseElements(courseUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof courseControllerGetCourseElements>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!courseUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const courseControllerSubmitExercise = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/course/submitExercise`, undefined, options);
};

export type CourseControllerSubmitExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerSubmitExercise>>
>;

export type CourseControllerSubmitExerciseMutationError = AxiosError<unknown>;

export const useCourseControllerSubmitExercise = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerSubmitExercise>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerSubmitExercise>>,
    TVariables
  > = () => {
    return courseControllerSubmitExercise(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerSubmitExercise>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const courseControllerGetElement = (
  elementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/course/element/${elementUUID}`, options);
};

export const getCourseControllerGetElementQueryKey = (elementUUID: string) => [
  `/api/course/element/${elementUUID}`,
];

export type CourseControllerGetElementQueryResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerGetElement>>
>;
export type CourseControllerGetElementQueryError = AxiosError<unknown>;

export const useCourseControllerGetElement = <
  TData = Awaited<ReturnType<typeof courseControllerGetElement>>,
  TError = AxiosError<unknown>
>(
  elementUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof courseControllerGetElement>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCourseControllerGetElementQueryKey(elementUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof courseControllerGetElement>>
  > = ({ signal }) =>
    courseControllerGetElement(elementUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof courseControllerGetElement>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!elementUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const courseControllerRevertExercise = (
  elementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(
    `/api/course/revertExercise/${elementUUID}`,
    undefined,
    options
  );
};

export type CourseControllerRevertExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof courseControllerRevertExercise>>
>;

export type CourseControllerRevertExerciseMutationError = AxiosError<unknown>;

export const useCourseControllerRevertExercise = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof courseControllerRevertExercise>>,
    TError,
    { elementUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof courseControllerRevertExercise>>,
    { elementUUID: string }
  > = (props) => {
    const { elementUUID } = props ?? {};

    return courseControllerRevertExercise(elementUUID, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof courseControllerRevertExercise>>,
    TError,
    { elementUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const fileUploadControllerUploadFile = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/courseFile`, undefined, options);
};

export type FileUploadControllerUploadFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerUploadFile>>
>;

export type FileUploadControllerUploadFileMutationError = AxiosError<unknown>;

export const useFileUploadControllerUploadFile = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fileUploadControllerUploadFile>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fileUploadControllerUploadFile>>,
    TVariables
  > = () => {
    return fileUploadControllerUploadFile(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof fileUploadControllerUploadFile>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const fileUploadControllerGetFileUUID = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/courseFile/getFileUUID`, options);
};

export const getFileUploadControllerGetFileUUIDQueryKey = () => [
  `/api/courseFile/getFileUUID`,
];

export type FileUploadControllerGetFileUUIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerGetFileUUID>>
>;
export type FileUploadControllerGetFileUUIDQueryError = AxiosError<unknown>;

export const useFileUploadControllerGetFileUUID = <
  TData = Awaited<ReturnType<typeof fileUploadControllerGetFileUUID>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fileUploadControllerGetFileUUID>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFileUploadControllerGetFileUUIDQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fileUploadControllerGetFileUUID>>
  > = ({ signal }) =>
    fileUploadControllerGetFileUUID({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof fileUploadControllerGetFileUUID>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const fileUploadControllerGetFileInfo = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/courseFile/getFileInfo`, options);
};

export const getFileUploadControllerGetFileInfoQueryKey = () => [
  `/api/courseFile/getFileInfo`,
];

export type FileUploadControllerGetFileInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerGetFileInfo>>
>;
export type FileUploadControllerGetFileInfoQueryError = AxiosError<unknown>;

export const useFileUploadControllerGetFileInfo = <
  TData = Awaited<ReturnType<typeof fileUploadControllerGetFileInfo>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fileUploadControllerGetFileInfo>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFileUploadControllerGetFileInfoQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fileUploadControllerGetFileInfo>>
  > = ({ signal }) =>
    fileUploadControllerGetFileInfo({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof fileUploadControllerGetFileInfo>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const fileUploadControllerGetFile = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/courseFile/getFile`, options);
};

export const getFileUploadControllerGetFileQueryKey = () => [
  `/api/courseFile/getFile`,
];

export type FileUploadControllerGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerGetFile>>
>;
export type FileUploadControllerGetFileQueryError = AxiosError<unknown>;

export const useFileUploadControllerGetFile = <
  TData = Awaited<ReturnType<typeof fileUploadControllerGetFile>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fileUploadControllerGetFile>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFileUploadControllerGetFileQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fileUploadControllerGetFile>>
  > = ({ signal }) => fileUploadControllerGetFile({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof fileUploadControllerGetFile>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const statusControllerGetStatus = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/status`, options);
};

export const getStatusControllerGetStatusQueryKey = () => [`/api/status`];

export type StatusControllerGetStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof statusControllerGetStatus>>
>;
export type StatusControllerGetStatusQueryError = AxiosError<unknown>;

export const useStatusControllerGetStatus = <
  TData = Awaited<ReturnType<typeof statusControllerGetStatus>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof statusControllerGetStatus>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStatusControllerGetStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statusControllerGetStatus>>
  > = ({ signal }) => statusControllerGetStatus({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof statusControllerGetStatus>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerCreateTimetable = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable`, undefined, options);
};

export type TimetableControllerCreateTimetableMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerCreateTimetable>>
>;

export type TimetableControllerCreateTimetableMutationError =
  AxiosError<unknown>;

export const useTimetableControllerCreateTimetable = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerCreateTimetable>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerCreateTimetable>>,
    TVariables
  > = () => {
    return timetableControllerCreateTimetable(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerCreateTimetable>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerAddTimeTableElement = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/element`, undefined, options);
};

export type TimetableControllerAddTimeTableElementMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddTimeTableElement>>
>;

export type TimetableControllerAddTimeTableElementMutationError =
  AxiosError<unknown>;

export const useTimetableControllerAddTimeTableElement = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableElement>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableElement>>,
    TVariables
  > = () => {
    return timetableControllerAddTimeTableElement(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableElement>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerUpdateTimeTableElement = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/timetable/element`, undefined, options);
};

export type TimetableControllerUpdateTimeTableElementMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableElement>>
  >;

export type TimetableControllerUpdateTimeTableElementMutationError =
  AxiosError<unknown>;

export const useTimetableControllerUpdateTimeTableElement = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableElement>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableElement>>,
    TVariables
  > = () => {
    return timetableControllerUpdateTimeTableElement(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableElement>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetTimeTableElementDetailed = (
  elementUUID: string,
  date: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(
    `/api/timetable/element/detailed/${elementUUID}/${date}`,
    options
  );
};

export const getTimetableControllerGetTimeTableElementDetailedQueryKey = (
  elementUUID: string,
  date: string
) => [`/api/timetable/element/detailed/${elementUUID}/${date}`];

export type TimetableControllerGetTimeTableElementDetailedQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableElementDetailed>>
  >;
export type TimetableControllerGetTimeTableElementDetailedQueryError =
  AxiosError<unknown>;

export const useTimetableControllerGetTimeTableElementDetailed = <
  TData = Awaited<
    ReturnType<typeof timetableControllerGetTimeTableElementDetailed>
  >,
  TError = AxiosError<unknown>
>(
  elementUUID: string,
  date: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<
        ReturnType<typeof timetableControllerGetTimeTableElementDetailed>
      >,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetTimeTableElementDetailedQueryKey(
      elementUUID,
      date
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableElementDetailed>>
  > = ({ signal }) =>
    timetableControllerGetTimeTableElementDetailed(elementUUID, date, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableElementDetailed>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(elementUUID && date),
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerDeleteTimeTableElement = (
  elementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/timetable/element/${elementUUID}`, options);
};

export type TimetableControllerDeleteTimeTableElementMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableElement>>
  >;

export type TimetableControllerDeleteTimeTableElementMutationError =
  AxiosError<unknown>;

export const useTimetableControllerDeleteTimeTableElement = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableElement>>,
    TError,
    { elementUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableElement>>,
    { elementUUID: string }
  > = (props) => {
    const { elementUUID } = props ?? {};

    return timetableControllerDeleteTimeTableElement(elementUUID, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableElement>>,
    TError,
    { elementUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetTimeTableElement = (
  timeTableElementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(
    `/api/timetable/timeTableElement/${timeTableElementUUID}`,
    options
  );
};

export const getTimetableControllerGetTimeTableElementQueryKey = (
  timeTableElementUUID: string
) => [`/api/timetable/timeTableElement/${timeTableElementUUID}`];

export type TimetableControllerGetTimeTableElementQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetTimeTableElement>>
>;
export type TimetableControllerGetTimeTableElementQueryError =
  AxiosError<unknown>;

export const useTimetableControllerGetTimeTableElement = <
  TData = Awaited<ReturnType<typeof timetableControllerGetTimeTableElement>>,
  TError = AxiosError<unknown>
>(
  timeTableElementUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetTimeTableElement>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetTimeTableElementQueryKey(timeTableElementUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableElement>>
  > = ({ signal }) =>
    timetableControllerGetTimeTableElement(timeTableElementUUID, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableElement>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!timeTableElementUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Add a holiday to a school
 */
export const timetableControllerAddHoliday = (
  addHolidayDTO: AddHolidayDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Holiday>> => {
  return axios.post(`/api/timetable/holiday`, addHolidayDTO, options);
};

export type TimetableControllerAddHolidayMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddHoliday>>
>;
export type TimetableControllerAddHolidayMutationBody = AddHolidayDTO;
export type TimetableControllerAddHolidayMutationError = AxiosError<unknown>;

export const useTimetableControllerAddHoliday = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddHoliday>>,
    TError,
    { data: AddHolidayDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddHoliday>>,
    { data: AddHolidayDTO }
  > = (props) => {
    const { data } = props ?? {};

    return timetableControllerAddHoliday(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddHoliday>>,
    TError,
    { data: AddHolidayDTO },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Update a holiday of a school
 */
export const timetableControllerUpdateHoliday = (
  updateHolidayDTO: UpdateHolidayDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Holiday>> => {
  return axios.put(`/api/timetable/holiday`, updateHolidayDTO, options);
};

export type TimetableControllerUpdateHolidayMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerUpdateHoliday>>
>;
export type TimetableControllerUpdateHolidayMutationBody = UpdateHolidayDTO;
export type TimetableControllerUpdateHolidayMutationError = AxiosError<unknown>;

export const useTimetableControllerUpdateHoliday = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateHoliday>>,
    TError,
    { data: UpdateHolidayDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateHoliday>>,
    { data: UpdateHolidayDTO }
  > = (props) => {
    const { data } = props ?? {};

    return timetableControllerUpdateHoliday(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateHoliday>>,
    TError,
    { data: UpdateHolidayDTO },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Get all holidays of a school
 */
export const timetableControllerGetHoliday = (
  schoolUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Holiday[]>> => {
  return axios.get(`/api/timetable/holiday/${schoolUUID}`, options);
};

export const getTimetableControllerGetHolidayQueryKey = (
  schoolUUID: string
) => [`/api/timetable/holiday/${schoolUUID}`];

export type TimetableControllerGetHolidayQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetHoliday>>
>;
export type TimetableControllerGetHolidayQueryError = AxiosError<unknown>;

export const useTimetableControllerGetHoliday = <
  TData = Awaited<ReturnType<typeof timetableControllerGetHoliday>>,
  TError = AxiosError<unknown>
>(
  schoolUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetHoliday>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetHolidayQueryKey(schoolUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetHoliday>>
  > = ({ signal }) =>
    timetableControllerGetHoliday(schoolUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetHoliday>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!schoolUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Delete a holiday
 */
export const timetableControllerRemoveHoliday = (
  holidayUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<number>> => {
  return axios.delete(`/api/timetable/holiday/${holidayUUID}`, options);
};

export type TimetableControllerRemoveHolidayMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerRemoveHoliday>>
>;

export type TimetableControllerRemoveHolidayMutationError = AxiosError<unknown>;

export const useTimetableControllerRemoveHoliday = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerRemoveHoliday>>,
    TError,
    { holidayUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerRemoveHoliday>>,
    { holidayUUID: string }
  > = (props) => {
    const { holidayUUID } = props ?? {};

    return timetableControllerRemoveHoliday(holidayUUID, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerRemoveHoliday>>,
    TError,
    { holidayUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerAddTimeTableGrid = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/grid`, undefined, options);
};

export type TimetableControllerAddTimeTableGridMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddTimeTableGrid>>
>;

export type TimetableControllerAddTimeTableGridMutationError =
  AxiosError<unknown>;

export const useTimetableControllerAddTimeTableGrid = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableGrid>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableGrid>>,
    TVariables
  > = () => {
    return timetableControllerAddTimeTableGrid(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddTimeTableGrid>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerUpdateTimeTableGrid = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/timetable/grid`, undefined, options);
};

export type TimetableControllerUpdateTimeTableGridMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerUpdateTimeTableGrid>>
>;

export type TimetableControllerUpdateTimeTableGridMutationError =
  AxiosError<unknown>;

export const useTimetableControllerUpdateTimeTableGrid = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableGrid>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableGrid>>,
    TVariables
  > = () => {
    return timetableControllerUpdateTimeTableGrid(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateTimeTableGrid>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerAddOmit = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/omit`, undefined, options);
};

export type TimetableControllerAddOmitMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddOmit>>
>;

export type TimetableControllerAddOmitMutationError = AxiosError<unknown>;

export const useTimetableControllerAddOmit = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddOmit>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddOmit>>,
    TVariables
  > = () => {
    return timetableControllerAddOmit(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddOmit>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerRemoveOmit = (
  timeTableElementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/timetable/omit/${timeTableElementUUID}`, options);
};

export type TimetableControllerRemoveOmitMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerRemoveOmit>>
>;

export type TimetableControllerRemoveOmitMutationError = AxiosError<unknown>;

export const useTimetableControllerRemoveOmit = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerRemoveOmit>>,
    TError,
    { timeTableElementUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerRemoveOmit>>,
    { timeTableElementUUID: string }
  > = (props) => {
    const { timeTableElementUUID } = props ?? {};

    return timetableControllerRemoveOmit(timeTableElementUUID, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerRemoveOmit>>,
    TError,
    { timeTableElementUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerDeleteTimeTableGrid = (
  schoolUUId: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/timetable/grid/${schoolUUId}`, options);
};

export type TimetableControllerDeleteTimeTableGridMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerDeleteTimeTableGrid>>
>;

export type TimetableControllerDeleteTimeTableGridMutationError =
  AxiosError<unknown>;

export const useTimetableControllerDeleteTimeTableGrid = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableGrid>>,
    TError,
    { schoolUUId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableGrid>>,
    { schoolUUId: string }
  > = (props) => {
    const { schoolUUId } = props ?? {};

    return timetableControllerDeleteTimeTableGrid(schoolUUId, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerDeleteTimeTableGrid>>,
    TError,
    { schoolUUId: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetTimeTableGrid = (
  schoolUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/grid/${schoolUUID}`, options);
};

export const getTimetableControllerGetTimeTableGridQueryKey = (
  schoolUUID: string
) => [`/api/timetable/grid/${schoolUUID}`];

export type TimetableControllerGetTimeTableGridQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetTimeTableGrid>>
>;
export type TimetableControllerGetTimeTableGridQueryError = AxiosError<unknown>;

export const useTimetableControllerGetTimeTableGrid = <
  TData = Awaited<ReturnType<typeof timetableControllerGetTimeTableGrid>>,
  TError = AxiosError<unknown>
>(
  schoolUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetTimeTableGrid>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetTimeTableGridQueryKey(schoolUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableGrid>>
  > = ({ signal }) =>
    timetableControllerGetTimeTableGrid(schoolUUID, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetTimeTableGrid>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!schoolUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerRemoveBreak = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/timetable/grid/break`, options);
};

export type TimetableControllerRemoveBreakMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerRemoveBreak>>
>;

export type TimetableControllerRemoveBreakMutationError = AxiosError<unknown>;

export const useTimetableControllerRemoveBreak = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerRemoveBreak>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerRemoveBreak>>,
    TVariables
  > = () => {
    return timetableControllerRemoveBreak(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerRemoveBreak>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerUpdateBreak = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/timetable/grid/break`, undefined, options);
};

export type TimetableControllerUpdateBreakMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerUpdateBreak>>
>;

export type TimetableControllerUpdateBreakMutationError = AxiosError<unknown>;

export const useTimetableControllerUpdateBreak = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateBreak>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateBreak>>,
    TVariables
  > = () => {
    return timetableControllerUpdateBreak(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateBreak>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerAddBreak = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/grid/break`, undefined, options);
};

export type TimetableControllerAddBreakMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddBreak>>
>;

export type TimetableControllerAddBreakMutationError = AxiosError<unknown>;

export const useTimetableControllerAddBreak = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddBreak>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddBreak>>,
    TVariables
  > = () => {
    return timetableControllerAddBreak(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddBreak>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetFreeRooms = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/freeRooms`, options);
};

export const getTimetableControllerGetFreeRoomsQueryKey = () => [
  `/api/timetable/freeRooms`,
];

export type TimetableControllerGetFreeRoomsQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetFreeRooms>>
>;
export type TimetableControllerGetFreeRoomsQueryError = AxiosError<unknown>;

export const useTimetableControllerGetFreeRooms = <
  TData = Awaited<ReturnType<typeof timetableControllerGetFreeRooms>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof timetableControllerGetFreeRooms>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTimetableControllerGetFreeRoomsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetFreeRooms>>
  > = ({ signal }) =>
    timetableControllerGetFreeRooms({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetFreeRooms>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerAddSubstitution = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/substitution`, undefined, options);
};

export type TimetableControllerAddSubstitutionMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddSubstitution>>
>;

export type TimetableControllerAddSubstitutionMutationError =
  AxiosError<unknown>;

export const useTimetableControllerAddSubstitution = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddSubstitution>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddSubstitution>>,
    TVariables
  > = () => {
    return timetableControllerAddSubstitution(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddSubstitution>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerUpdateSubstitution = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/timetable/substitution`, undefined, options);
};

export type TimetableControllerUpdateSubstitutionMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerUpdateSubstitution>>
>;

export type TimetableControllerUpdateSubstitutionMutationError =
  AxiosError<unknown>;

export const useTimetableControllerUpdateSubstitution = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateSubstitution>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateSubstitution>>,
    TVariables
  > = () => {
    return timetableControllerUpdateSubstitution(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateSubstitution>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetSubstitution = (
  elementUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/substitution/${elementUUID}`, options);
};

export const getTimetableControllerGetSubstitutionQueryKey = (
  elementUUID: string
) => [`/api/timetable/substitution/${elementUUID}`];

export type TimetableControllerGetSubstitutionQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetSubstitution>>
>;
export type TimetableControllerGetSubstitutionQueryError = AxiosError<unknown>;

export const useTimetableControllerGetSubstitution = <
  TData = Awaited<ReturnType<typeof timetableControllerGetSubstitution>>,
  TError = AxiosError<unknown>
>(
  elementUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetSubstitution>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetSubstitutionQueryKey(elementUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetSubstitution>>
  > = ({ signal }) =>
    timetableControllerGetSubstitution(elementUUID, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetSubstitution>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!elementUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerRemoveSubstitution = (
  substitutionUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(
    `/api/timetable/substitution/${substitutionUUID}`,
    options
  );
};

export type TimetableControllerRemoveSubstitutionMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerRemoveSubstitution>>
>;

export type TimetableControllerRemoveSubstitutionMutationError =
  AxiosError<unknown>;

export const useTimetableControllerRemoveSubstitution = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerRemoveSubstitution>>,
    TError,
    { substitutionUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerRemoveSubstitution>>,
    { substitutionUUID: string }
  > = (props) => {
    const { substitutionUUID } = props ?? {};

    return timetableControllerRemoveSubstitution(
      substitutionUUID,
      axiosOptions
    );
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerRemoveSubstitution>>,
    TError,
    { substitutionUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerAddExam = (
  addExamDTO: AddExamDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timetable/exam`, addExamDTO, options);
};

export type TimetableControllerAddExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerAddExam>>
>;
export type TimetableControllerAddExamMutationBody = AddExamDTO;
export type TimetableControllerAddExamMutationError = AxiosError<unknown>;

export const useTimetableControllerAddExam = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerAddExam>>,
    TError,
    { data: AddExamDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerAddExam>>,
    { data: AddExamDTO }
  > = (props) => {
    const { data } = props ?? {};

    return timetableControllerAddExam(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerAddExam>>,
    TError,
    { data: AddExamDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerUpdateExam = (
  updateExamDTO: UpdateExamDTO,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.put(`/api/timetable/exam`, updateExamDTO, options);
};

export type TimetableControllerUpdateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerUpdateExam>>
>;
export type TimetableControllerUpdateExamMutationBody = UpdateExamDTO;
export type TimetableControllerUpdateExamMutationError = AxiosError<unknown>;

export const useTimetableControllerUpdateExam = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerUpdateExam>>,
    TError,
    { data: UpdateExamDTO },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerUpdateExam>>,
    { data: UpdateExamDTO }
  > = (props) => {
    const { data } = props ?? {};

    return timetableControllerUpdateExam(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerUpdateExam>>,
    TError,
    { data: UpdateExamDTO },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetExams = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/exam`, options);
};

export const getTimetableControllerGetExamsQueryKey = () => [
  `/api/timetable/exam`,
];

export type TimetableControllerGetExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetExams>>
>;
export type TimetableControllerGetExamsQueryError = AxiosError<unknown>;

export const useTimetableControllerGetExams = <
  TData = Awaited<ReturnType<typeof timetableControllerGetExams>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof timetableControllerGetExams>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTimetableControllerGetExamsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetExams>>
  > = ({ signal }) => timetableControllerGetExams({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetExams>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerGetExam = (
  examUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/exam/${examUUID}`, options);
};

export const getTimetableControllerGetExamQueryKey = (examUUID: string) => [
  `/api/timetable/exam/${examUUID}`,
];

export type TimetableControllerGetExamQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetExam>>
>;
export type TimetableControllerGetExamQueryError = AxiosError<unknown>;

export const useTimetableControllerGetExam = <
  TData = Awaited<ReturnType<typeof timetableControllerGetExam>>,
  TError = AxiosError<unknown>
>(
  examUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetExam>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTimetableControllerGetExamQueryKey(examUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetExam>>
  > = ({ signal }) =>
    timetableControllerGetExam(examUUID, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetExam>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!examUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerDeleteExam = (
  examUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/timetable/exam/${examUUID}`, options);
};

export type TimetableControllerDeleteExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerDeleteExam>>
>;

export type TimetableControllerDeleteExamMutationError = AxiosError<unknown>;

export const useTimetableControllerDeleteExam = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timetableControllerDeleteExam>>,
    TError,
    { examUUID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timetableControllerDeleteExam>>,
    { examUUID: string }
  > = (props) => {
    const { examUUID } = props ?? {};

    return timetableControllerDeleteExam(examUUID, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timetableControllerDeleteExam>>,
    TError,
    { examUUID: string },
    TContext
  >(mutationFn, mutationOptions);
};
export const timetableControllerGetExamsOfSchool = (
  schoolUUID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/timetable/exams/${schoolUUID}`, options);
};

export const getTimetableControllerGetExamsOfSchoolQueryKey = (
  schoolUUID: string
) => [`/api/timetable/exams/${schoolUUID}`];

export type TimetableControllerGetExamsOfSchoolQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetExamsOfSchool>>
>;
export type TimetableControllerGetExamsOfSchoolQueryError = AxiosError<unknown>;

export const useTimetableControllerGetExamsOfSchool = <
  TData = Awaited<ReturnType<typeof timetableControllerGetExamsOfSchool>>,
  TError = AxiosError<unknown>
>(
  schoolUUID: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetExamsOfSchool>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetExamsOfSchoolQueryKey(schoolUUID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetExamsOfSchool>>
  > = ({ signal }) =>
    timetableControllerGetExamsOfSchool(schoolUUID, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetExamsOfSchool>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!schoolUUID,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timetableControllerGetTimetable = (
  classUUID: string,
  dateString: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(
    `/api/timetable/timetable/${classUUID}/${dateString}`,
    options
  );
};

export const getTimetableControllerGetTimetableQueryKey = (
  classUUID: string,
  dateString: string
) => [`/api/timetable/timetable/${classUUID}/${dateString}`];

export type TimetableControllerGetTimetableQueryResult = NonNullable<
  Awaited<ReturnType<typeof timetableControllerGetTimetable>>
>;
export type TimetableControllerGetTimetableQueryError = AxiosError<unknown>;

export const useTimetableControllerGetTimetable = <
  TData = Awaited<ReturnType<typeof timetableControllerGetTimetable>>,
  TError = AxiosError<unknown>
>(
  classUUID: string,
  dateString: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof timetableControllerGetTimetable>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTimetableControllerGetTimetableQueryKey(classUUID, dateString);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof timetableControllerGetTimetable>>
  > = ({ signal }) =>
    timetableControllerGetTimetable(classUUID, dateString, {
      signal,
      ...axiosOptions,
    });

  const query = useQuery<
    Awaited<ReturnType<typeof timetableControllerGetTimetable>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(classUUID && dateString),
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const timezoneControllerImportTimezones = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timezone/importTimezones`, undefined, options);
};

export type TimezoneControllerImportTimezonesMutationResult = NonNullable<
  Awaited<ReturnType<typeof timezoneControllerImportTimezones>>
>;

export type TimezoneControllerImportTimezonesMutationError =
  AxiosError<unknown>;

export const useTimezoneControllerImportTimezones = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timezoneControllerImportTimezones>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timezoneControllerImportTimezones>>,
    TVariables
  > = () => {
    return timezoneControllerImportTimezones(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timezoneControllerImportTimezones>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const timezoneControllerGetTimezoneByName = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/timezone/getTimezoneByName`, undefined, options);
};

export type TimezoneControllerGetTimezoneByNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof timezoneControllerGetTimezoneByName>>
>;

export type TimezoneControllerGetTimezoneByNameMutationError =
  AxiosError<unknown>;

export const useTimezoneControllerGetTimezoneByName = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof timezoneControllerGetTimezoneByName>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof timezoneControllerGetTimezoneByName>>,
    TVariables
  > = () => {
    return timezoneControllerGetTimezoneByName(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof timezoneControllerGetTimezoneByName>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const untisImportControllerImportUntis = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/untis`, undefined, options);
};

export type UntisImportControllerImportUntisMutationResult = NonNullable<
  Awaited<ReturnType<typeof untisImportControllerImportUntis>>
>;

export type UntisImportControllerImportUntisMutationError = AxiosError<unknown>;

export const useUntisImportControllerImportUntis = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof untisImportControllerImportUntis>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof untisImportControllerImportUntis>>,
    TVariables
  > = () => {
    return untisImportControllerImportUntis(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof untisImportControllerImportUntis>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const usersControllerRegisterUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/user/register`, undefined, options);
};

export type UsersControllerRegisterUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersControllerRegisterUser>>
>;

export type UsersControllerRegisterUserMutationError = AxiosError<unknown>;

export const useUsersControllerRegisterUser = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersControllerRegisterUser>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersControllerRegisterUser>>,
    TVariables
  > = () => {
    return usersControllerRegisterUser(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof usersControllerRegisterUser>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
export const usersControllerActivateAccount = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/user/activateAccount`, undefined, options);
};

export type UsersControllerActivateAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersControllerActivateAccount>>
>;

export type UsersControllerActivateAccountMutationError = AxiosError<unknown>;

export const useUsersControllerActivateAccount = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersControllerActivateAccount>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersControllerActivateAccount>>,
    TVariables
  > = () => {
    return usersControllerActivateAccount(axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof usersControllerActivateAccount>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
